Require Import ZArith.

From mathcomp Require Import all_ssreflect all_algebra.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Import GRing.Theory Num.Theory.

Local Open Scope ring_scope.


(*  We define an *opaque* cast:                                                *)
(*     rat_of_Z : Z -> rat                                                     *)
(* which converts integers in the type Z of integers in binary representation, *)
(* into the type rat of rational numbers from the MathComp lib, which is       *)
(* equipped with all the (appropriate) structures of ssralg but not relevant   *)
(* for inner computations. *)
(* This cast is useful to control computation when doing proofs on expressions *)
(* that feature "large" numeral constants. Also this is a mandatory ingredient *)
(* in the custom ring/field tactics we use. *)

(* Definition of the cast. In our case, it is crucial that this cast is *)
(* opaque, otherwise we cannot control when binary integers are converted *)
(* to (unary) rationals.*)

Definition rat_of_Z_ (z : Z) : rat :=
  match z with
  | Z0 => zeroq
  | Zpos p => (Posz (nat_of_P p))%:Q
  | Zneg p => - (Posz (nat_of_P p))%:Q
  end.

Arguments rat_of_Z_ z : simpl never.

(* Opacification of rat_of_Z. A mere 'locked' would not word for it is not *)
(* fully opaque and would be actually harmeful in the hard-wired post *)
(* treatement of the postconditions generated by the (coq, primitive) field *)
(* tactic. *) 

Module Type RatOfZSig.
Parameter rat_of_Z : Z -> rat. Axiom rat_of_ZEdef : rat_of_Z = rat_of_Z_.
End RatOfZSig.

Module rat_of_ZDef : RatOfZSig.
Definition rat_of_Z : Z -> rat := rat_of_Z_.
Definition rat_of_ZEdef := erefl rat_of_Z.
End rat_of_ZDef.

Export rat_of_ZDef.

(* Proofs that Z is a correct ring of coefficients for rat *)
Lemma nat_of_pos_xI p : nat_of_pos (p~1) = (nat_of_pos p).*2.+1.
Proof. by rewrite /= NatTrec.doubleE. Qed.

Lemma nat_of_pos_x0 p : nat_of_pos (p~0) = (nat_of_pos p).*2.
Proof. by rewrite /= NatTrec.doubleE. Qed.

Definition nat_of_posE := (nat_of_pos_x0, nat_of_pos_xI).

Lemma nat_of_P_E n : Pos.to_nat n = nat_of_pos n.
Proof.
elim: n => // p IH; rewrite nat_of_posE -IH -addnn;
  by rewrite /Pos.to_nat /= Pmult_nat_mult multE mulnS muln1.
Qed.

Lemma rat_of_Z_neg b : rat_of_Z_ (Z.neg b) = - rat_of_Z_ (Z.pos b).
Proof. by []. Qed.

Lemma rat_of_Z_opp b : rat_of_Z_ (Z.opp b) = - rat_of_Z_ b.
Proof. by case: b => //= p; rewrite opprK. Qed.

Lemma rat_of_Z_add a b :
  rat_of_Z_ (Z.pos (a + b)) = rat_of_Z_ (Z.pos a) + rat_of_Z_ (Z.pos b).
Proof.
by rewrite /rat_of_Z_ /= !nat_of_P_E -!mulrzDl -!PoszD nat_of_add_pos. 
Qed. 

Lemma mulrzPD (R : zmodType) (r : R) :
  {morph (fun x => r *~ (Posz x)) : x y / (x + y)%N >-> x + y}.
Proof. by move=> x y /=; rewrite PoszD mulrzDl. Qed.

Lemma mulrzS (R : ringType) (r : R) n : n.+1%:~R * r = r + (n%:~R * r).
Proof. by rewrite -pmulrn mulrS pmulrn mulrDl mul1r. Qed.

Lemma Pos_mul_xO_l p q : Pos.mul (xO p) q = xO (p * q).
Proof. by rewrite Pos.mul_comm Pos.mul_xO_r Pos.mul_comm. Qed.

Lemma Pos_mul_xI_l p q : Pos.mul (xI p) q = Pos.add q (xO (p * q)).
Proof. by rewrite Pos.mul_comm Pos.mul_xI_r Pos.mul_comm. Qed.

Lemma rat_of_Z_mul a b :
  rat_of_Z_ (Z.pos (a * b)) = rat_of_Z_ (Z.pos a) * rat_of_Z_ (Z.pos b).
Proof.
rewrite /rat_of_Z_ /= !nat_of_P_E; elim: a => [p IH|p IH|]; rewrite ?mul1r //.
  rewrite Pos_mul_xI_l nat_of_add_pos !nat_of_posE.
  by rewrite mulrzS -!addnn !mulrzPD mulrDl -!IH.
by rewrite Pos_mul_xO_l !nat_of_posE -!addnn !mulrzPD mulrDl -!IH.
Qed.

Lemma rat_of_Z_sub a b :
  rat_of_Z_ (Z.pos_sub a b) = rat_of_Z_ (Z.pos a) - rat_of_Z_ (Z.pos b).
Proof.
rewrite /rat_of_Z_ /= !nat_of_P_E.
case: (Z.pos_sub a b) (Z.pos_sub_discr a b) => [->|c ->|c ->].
  by rewrite subrr.
  by rewrite  nat_of_add_pos mulrzPD addrAC subrr add0r -nat_of_P_E.
by rewrite nat_of_add_pos mulrzPD opprD addrA subrr add0r -nat_of_P_E.
Qed.

Lemma rat_of_Z_0 : zeroq = rat_of_Z 0.
Proof. by rewrite rat_of_ZEdef. Qed.

Lemma rat_of_Z_1 : oneq = rat_of_Z 1.
Proof. by rewrite rat_of_ZEdef. Qed.


(* For an efficient solving of constraints generated by field that only 
involve constants *)

Lemma rat_of_Z_eq0 x : (rat_of_Z_ x == 0) =  Z.eqb x Z0.
Proof.
suff pN0 p : (Pos.to_nat p == 0 :> int) = false.
  by case: x => [| p | p ] //; rewrite ?oppr_eq0 intq_eq0 pN0.
rewrite eqz_nat nat_of_P_E; apply: negPf.
elim: p => // p ihp.
by rewrite nat_of_pos_x0 -muln2 muln_eq0 negb_or ihp.
Qed.

(* Compatibility with order. This is a stub. *)

Lemma rat_of_Z_Zpos (z : positive) : 0 < rat_of_Z (Zpos z).
Proof.
rewrite rat_of_ZEdef /rat_of_Z_ /=; case: (Pos2Nat.is_succ z)=> n -> {z}.
by rewrite -[0]/(0%:Q) ltr_nat.
Qed.
