From HB Require Import structures.
Require Import ZArith.
From mathcomp Require Import all_ssreflect all_algebra.
From mathcomp.zify Require Export ssrZ.
Require Import tactics.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Import Order.Theory GRing.Theory Num.Theory.

Local Open Scope ring_scope.

(*  We define an *opaque* cast:                                                *)
(*     rat_of_Z : Z -> rat                                                     *)
(* which converts integers in the type Z of integers in binary representation, *)
(* into the type rat of rational numbers from the MathComp lib, which is       *)
(* equipped with all the (appropriate) structures of ssralg but not relevant   *)
(* for inner computations. *)
(* This cast is useful to control computation when doing proofs on expressions *)
(* that feature "large" numeral constants. Also this is a mandatory ingredient *)
(* in the custom ring/field tactics we use. *)

(* Definition of the cast. In our case, it is crucial that this cast is *)
(* opaque, otherwise we cannot control when binary integers are converted *)
(* to (unary) rationals.*)

(* Opacification of rat_of_Z. A mere 'locked' would not word for it is not *)
(* fully opaque and would be actually harmeful in the hard-wired post *)
(* treatement of the postconditions generated by the (coq, primitive) field *)
(* tactic. *) 

Module Type RatOfZSig.
Parameter rat_of_Z : Z -> rat.
Axiom rat_of_ZEdef : rat_of_Z = (fun x : Z => (int_of_Z x)%:Q).
End RatOfZSig.

Module rat_of_ZDef : RatOfZSig.
Definition rat_of_Z (x : Z) := (int_of_Z x)%:Q.
Definition rat_of_ZEdef := erefl rat_of_Z.
End rat_of_ZDef.

Export rat_of_ZDef.

Fact rat_of_Z_is_additive : additive rat_of_Z.
Proof. by move=> m n; rewrite rat_of_ZEdef !raddfB. Qed.

HB.instance Definition _ :=
  GRing.isAdditive.Build Z rat rat_of_Z rat_of_Z_is_additive.

Fact rat_of_Z_is_multiplicative : multiplicative rat_of_Z.
Proof. by rewrite rat_of_ZEdef; exact: rmorphismMP (_ \o _). Qed.

HB.instance Definition _ :=
  GRing.isMultiplicative.Build Z rat rat_of_Z rat_of_Z_is_multiplicative.

Lemma zify_rat_of_Z_subproof n : rat_of_Z n = (int_of_Z n)%:~R.
Proof. by rewrite rat_of_ZEdef. Qed.

Canonical zify_rat_of_Z n :=
  ZifyRing (rat_of_Z n) (int_of_Z n) (zify_rat_of_Z_subproof n).

(* Compatibility with order. This is a stub. *)

Lemma rat_of_Z_Zpos (z : positive) : 0 < rat_of_Z (Zpos z).
Proof. by ring_lia. Qed.
#[export] Hint Resolve rat_of_Z_Zpos : core.

Fact lt_rat_of_Z (n m : Z) : (n < m)%Z -> rat_of_Z n < rat_of_Z m.
Proof. by ring_lia. Qed.

Fact le_rat_of_Z (n m : Z) : (n <= m)%Z -> rat_of_Z n <= rat_of_Z m.
Proof. by ring_lia. Qed.

Lemma rat_of_Z_ZposW z : 0 <= rat_of_Z (Zpos z).
Proof. exact: ltW. Qed.

Lemma rat_of_Z_of_nat n : rat_of_Z (Z.of_nat n) = n%:Q.
Proof. by apply/eqP; ring_lia. Qed.

Lemma rat_of_Z_pow z n : rat_of_Z (z ^ Z.of_nat n) = rat_of_Z z ^ n.
Proof.
rewrite /exprz -rmorphXn -Zpower_nat_Z; congr rat_of_Z.
by elim: n => //= n ->; rewrite exprS.
Qed.
#[export] Hint Resolve rat_of_Z_ZposW : core.
